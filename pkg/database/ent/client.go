// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"

	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/attribute"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/attributetype"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/attributetypestotemplates"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/authorizationpolicy"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/certification"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/certificationtemplate"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/company"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/itembatch"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/itembatchtoitembatch"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/migrate"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/session"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/user"
	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/ent/userstocompany"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Attribute is the client for interacting with the Attribute builders.
	Attribute *AttributeClient
	// AttributeType is the client for interacting with the AttributeType builders.
	AttributeType *AttributeTypeClient
	// AttributeTypesToTemplates is the client for interacting with the AttributeTypesToTemplates builders.
	AttributeTypesToTemplates *AttributeTypesToTemplatesClient
	// AuthorizationPolicy is the client for interacting with the AuthorizationPolicy builders.
	AuthorizationPolicy *AuthorizationPolicyClient
	// Certification is the client for interacting with the Certification builders.
	Certification *CertificationClient
	// CertificationTemplate is the client for interacting with the CertificationTemplate builders.
	CertificationTemplate *CertificationTemplateClient
	// Company is the client for interacting with the Company builders.
	Company *CompanyClient
	// ItemBatch is the client for interacting with the ItemBatch builders.
	ItemBatch *ItemBatchClient
	// ItemBatchToItemBatch is the client for interacting with the ItemBatchToItemBatch builders.
	ItemBatchToItemBatch *ItemBatchToItemBatchClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UsersToCompany is the client for interacting with the UsersToCompany builders.
	UsersToCompany *UsersToCompanyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Attribute = NewAttributeClient(c.config)
	c.AttributeType = NewAttributeTypeClient(c.config)
	c.AttributeTypesToTemplates = NewAttributeTypesToTemplatesClient(c.config)
	c.AuthorizationPolicy = NewAuthorizationPolicyClient(c.config)
	c.Certification = NewCertificationClient(c.config)
	c.CertificationTemplate = NewCertificationTemplateClient(c.config)
	c.Company = NewCompanyClient(c.config)
	c.ItemBatch = NewItemBatchClient(c.config)
	c.ItemBatchToItemBatch = NewItemBatchToItemBatchClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.User = NewUserClient(c.config)
	c.UsersToCompany = NewUsersToCompanyClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		Attribute:                 NewAttributeClient(cfg),
		AttributeType:             NewAttributeTypeClient(cfg),
		AttributeTypesToTemplates: NewAttributeTypesToTemplatesClient(cfg),
		AuthorizationPolicy:       NewAuthorizationPolicyClient(cfg),
		Certification:             NewCertificationClient(cfg),
		CertificationTemplate:     NewCertificationTemplateClient(cfg),
		Company:                   NewCompanyClient(cfg),
		ItemBatch:                 NewItemBatchClient(cfg),
		ItemBatchToItemBatch:      NewItemBatchToItemBatchClient(cfg),
		Session:                   NewSessionClient(cfg),
		User:                      NewUserClient(cfg),
		UsersToCompany:            NewUsersToCompanyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		Attribute:                 NewAttributeClient(cfg),
		AttributeType:             NewAttributeTypeClient(cfg),
		AttributeTypesToTemplates: NewAttributeTypesToTemplatesClient(cfg),
		AuthorizationPolicy:       NewAuthorizationPolicyClient(cfg),
		Certification:             NewCertificationClient(cfg),
		CertificationTemplate:     NewCertificationTemplateClient(cfg),
		Company:                   NewCompanyClient(cfg),
		ItemBatch:                 NewItemBatchClient(cfg),
		ItemBatchToItemBatch:      NewItemBatchToItemBatchClient(cfg),
		Session:                   NewSessionClient(cfg),
		User:                      NewUserClient(cfg),
		UsersToCompany:            NewUsersToCompanyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Attribute.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Attribute.Use(hooks...)
	c.AttributeType.Use(hooks...)
	c.AttributeTypesToTemplates.Use(hooks...)
	c.AuthorizationPolicy.Use(hooks...)
	c.Certification.Use(hooks...)
	c.CertificationTemplate.Use(hooks...)
	c.Company.Use(hooks...)
	c.ItemBatch.Use(hooks...)
	c.ItemBatchToItemBatch.Use(hooks...)
	c.Session.Use(hooks...)
	c.User.Use(hooks...)
	c.UsersToCompany.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.Attribute.Intercept(interceptors...)
	c.AttributeType.Intercept(interceptors...)
	c.AttributeTypesToTemplates.Intercept(interceptors...)
	c.AuthorizationPolicy.Intercept(interceptors...)
	c.Certification.Intercept(interceptors...)
	c.CertificationTemplate.Intercept(interceptors...)
	c.Company.Intercept(interceptors...)
	c.ItemBatch.Intercept(interceptors...)
	c.ItemBatchToItemBatch.Intercept(interceptors...)
	c.Session.Intercept(interceptors...)
	c.User.Intercept(interceptors...)
	c.UsersToCompany.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AttributeMutation:
		return c.Attribute.mutate(ctx, m)
	case *AttributeTypeMutation:
		return c.AttributeType.mutate(ctx, m)
	case *AttributeTypesToTemplatesMutation:
		return c.AttributeTypesToTemplates.mutate(ctx, m)
	case *AuthorizationPolicyMutation:
		return c.AuthorizationPolicy.mutate(ctx, m)
	case *CertificationMutation:
		return c.Certification.mutate(ctx, m)
	case *CertificationTemplateMutation:
		return c.CertificationTemplate.mutate(ctx, m)
	case *CompanyMutation:
		return c.Company.mutate(ctx, m)
	case *ItemBatchMutation:
		return c.ItemBatch.mutate(ctx, m)
	case *ItemBatchToItemBatchMutation:
		return c.ItemBatchToItemBatch.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UsersToCompanyMutation:
		return c.UsersToCompany.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AttributeClient is a client for the Attribute schema.
type AttributeClient struct {
	config
}

// NewAttributeClient returns a client for the Attribute from the given config.
func NewAttributeClient(c config) *AttributeClient {
	return &AttributeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attribute.Hooks(f(g(h())))`.
func (c *AttributeClient) Use(hooks ...Hook) {
	c.hooks.Attribute = append(c.hooks.Attribute, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attribute.Intercept(f(g(h())))`.
func (c *AttributeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Attribute = append(c.inters.Attribute, interceptors...)
}

// Create returns a builder for creating a Attribute entity.
func (c *AttributeClient) Create() *AttributeCreate {
	mutation := newAttributeMutation(c.config, OpCreate)
	return &AttributeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attribute entities.
func (c *AttributeClient) CreateBulk(builders ...*AttributeCreate) *AttributeCreateBulk {
	return &AttributeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attribute.
func (c *AttributeClient) Update() *AttributeUpdate {
	mutation := newAttributeMutation(c.config, OpUpdate)
	return &AttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeClient) UpdateOne(a *Attribute) *AttributeUpdateOne {
	mutation := newAttributeMutation(c.config, OpUpdateOne, withAttribute(a))
	return &AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeClient) UpdateOneID(id uuid.UUID) *AttributeUpdateOne {
	mutation := newAttributeMutation(c.config, OpUpdateOne, withAttributeID(id))
	return &AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attribute.
func (c *AttributeClient) Delete() *AttributeDelete {
	mutation := newAttributeMutation(c.config, OpDelete)
	return &AttributeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeClient) DeleteOne(a *Attribute) *AttributeDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeClient) DeleteOneID(id uuid.UUID) *AttributeDeleteOne {
	builder := c.Delete().Where(attribute.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeDeleteOne{builder}
}

// Query returns a query builder for Attribute.
func (c *AttributeClient) Query() *AttributeQuery {
	return &AttributeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttribute},
		inters: c.Interceptors(),
	}
}

// Get returns a Attribute entity by its id.
func (c *AttributeClient) Get(ctx context.Context, id uuid.UUID) (*Attribute, error) {
	return c.Query().Where(attribute.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeClient) GetX(ctx context.Context, id uuid.UUID) *Attribute {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCertification queries the certification edge of a Attribute.
func (c *AttributeClient) QueryCertification(a *Attribute) *CertificationQuery {
	query := (&CertificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attribute.Table, attribute.FieldID, id),
			sqlgraph.To(certification.Table, certification.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attribute.CertificationTable, attribute.CertificationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttributeType queries the attributeType edge of a Attribute.
func (c *AttributeClient) QueryAttributeType(a *Attribute) *AttributeTypeQuery {
	query := (&AttributeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attribute.Table, attribute.FieldID, id),
			sqlgraph.To(attributetype.Table, attributetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attribute.AttributeTypeTable, attribute.AttributeTypeColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeClient) Hooks() []Hook {
	return c.hooks.Attribute
}

// Interceptors returns the client interceptors.
func (c *AttributeClient) Interceptors() []Interceptor {
	return c.inters.Attribute
}

func (c *AttributeClient) mutate(ctx context.Context, m *AttributeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Attribute mutation op: %q", m.Op())
	}
}

// AttributeTypeClient is a client for the AttributeType schema.
type AttributeTypeClient struct {
	config
}

// NewAttributeTypeClient returns a client for the AttributeType from the given config.
func NewAttributeTypeClient(c config) *AttributeTypeClient {
	return &AttributeTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attributetype.Hooks(f(g(h())))`.
func (c *AttributeTypeClient) Use(hooks ...Hook) {
	c.hooks.AttributeType = append(c.hooks.AttributeType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attributetype.Intercept(f(g(h())))`.
func (c *AttributeTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AttributeType = append(c.inters.AttributeType, interceptors...)
}

// Create returns a builder for creating a AttributeType entity.
func (c *AttributeTypeClient) Create() *AttributeTypeCreate {
	mutation := newAttributeTypeMutation(c.config, OpCreate)
	return &AttributeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AttributeType entities.
func (c *AttributeTypeClient) CreateBulk(builders ...*AttributeTypeCreate) *AttributeTypeCreateBulk {
	return &AttributeTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AttributeType.
func (c *AttributeTypeClient) Update() *AttributeTypeUpdate {
	mutation := newAttributeTypeMutation(c.config, OpUpdate)
	return &AttributeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeTypeClient) UpdateOne(at *AttributeType) *AttributeTypeUpdateOne {
	mutation := newAttributeTypeMutation(c.config, OpUpdateOne, withAttributeType(at))
	return &AttributeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeTypeClient) UpdateOneID(id uuid.UUID) *AttributeTypeUpdateOne {
	mutation := newAttributeTypeMutation(c.config, OpUpdateOne, withAttributeTypeID(id))
	return &AttributeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AttributeType.
func (c *AttributeTypeClient) Delete() *AttributeTypeDelete {
	mutation := newAttributeTypeMutation(c.config, OpDelete)
	return &AttributeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeTypeClient) DeleteOne(at *AttributeType) *AttributeTypeDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeTypeClient) DeleteOneID(id uuid.UUID) *AttributeTypeDeleteOne {
	builder := c.Delete().Where(attributetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeTypeDeleteOne{builder}
}

// Query returns a query builder for AttributeType.
func (c *AttributeTypeClient) Query() *AttributeTypeQuery {
	return &AttributeTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttributeType},
		inters: c.Interceptors(),
	}
}

// Get returns a AttributeType entity by its id.
func (c *AttributeTypeClient) Get(ctx context.Context, id uuid.UUID) (*AttributeType, error) {
	return c.Query().Where(attributetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeTypeClient) GetX(ctx context.Context, id uuid.UUID) *AttributeType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a AttributeType.
func (c *AttributeTypeClient) QueryCompany(at *AttributeType) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributetype.Table, attributetype.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attributetype.CompanyTable, attributetype.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeTypeClient) Hooks() []Hook {
	return c.hooks.AttributeType
}

// Interceptors returns the client interceptors.
func (c *AttributeTypeClient) Interceptors() []Interceptor {
	return c.inters.AttributeType
}

func (c *AttributeTypeClient) mutate(ctx context.Context, m *AttributeTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AttributeType mutation op: %q", m.Op())
	}
}

// AttributeTypesToTemplatesClient is a client for the AttributeTypesToTemplates schema.
type AttributeTypesToTemplatesClient struct {
	config
}

// NewAttributeTypesToTemplatesClient returns a client for the AttributeTypesToTemplates from the given config.
func NewAttributeTypesToTemplatesClient(c config) *AttributeTypesToTemplatesClient {
	return &AttributeTypesToTemplatesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attributetypestotemplates.Hooks(f(g(h())))`.
func (c *AttributeTypesToTemplatesClient) Use(hooks ...Hook) {
	c.hooks.AttributeTypesToTemplates = append(c.hooks.AttributeTypesToTemplates, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `attributetypestotemplates.Intercept(f(g(h())))`.
func (c *AttributeTypesToTemplatesClient) Intercept(interceptors ...Interceptor) {
	c.inters.AttributeTypesToTemplates = append(c.inters.AttributeTypesToTemplates, interceptors...)
}

// Create returns a builder for creating a AttributeTypesToTemplates entity.
func (c *AttributeTypesToTemplatesClient) Create() *AttributeTypesToTemplatesCreate {
	mutation := newAttributeTypesToTemplatesMutation(c.config, OpCreate)
	return &AttributeTypesToTemplatesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AttributeTypesToTemplates entities.
func (c *AttributeTypesToTemplatesClient) CreateBulk(builders ...*AttributeTypesToTemplatesCreate) *AttributeTypesToTemplatesCreateBulk {
	return &AttributeTypesToTemplatesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AttributeTypesToTemplates.
func (c *AttributeTypesToTemplatesClient) Update() *AttributeTypesToTemplatesUpdate {
	mutation := newAttributeTypesToTemplatesMutation(c.config, OpUpdate)
	return &AttributeTypesToTemplatesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttributeTypesToTemplatesClient) UpdateOne(attt *AttributeTypesToTemplates) *AttributeTypesToTemplatesUpdateOne {
	mutation := newAttributeTypesToTemplatesMutation(c.config, OpUpdateOne, withAttributeTypesToTemplates(attt))
	return &AttributeTypesToTemplatesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttributeTypesToTemplatesClient) UpdateOneID(id uuid.UUID) *AttributeTypesToTemplatesUpdateOne {
	mutation := newAttributeTypesToTemplatesMutation(c.config, OpUpdateOne, withAttributeTypesToTemplatesID(id))
	return &AttributeTypesToTemplatesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AttributeTypesToTemplates.
func (c *AttributeTypesToTemplatesClient) Delete() *AttributeTypesToTemplatesDelete {
	mutation := newAttributeTypesToTemplatesMutation(c.config, OpDelete)
	return &AttributeTypesToTemplatesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AttributeTypesToTemplatesClient) DeleteOne(attt *AttributeTypesToTemplates) *AttributeTypesToTemplatesDeleteOne {
	return c.DeleteOneID(attt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AttributeTypesToTemplatesClient) DeleteOneID(id uuid.UUID) *AttributeTypesToTemplatesDeleteOne {
	builder := c.Delete().Where(attributetypestotemplates.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttributeTypesToTemplatesDeleteOne{builder}
}

// Query returns a query builder for AttributeTypesToTemplates.
func (c *AttributeTypesToTemplatesClient) Query() *AttributeTypesToTemplatesQuery {
	return &AttributeTypesToTemplatesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAttributeTypesToTemplates},
		inters: c.Interceptors(),
	}
}

// Get returns a AttributeTypesToTemplates entity by its id.
func (c *AttributeTypesToTemplatesClient) Get(ctx context.Context, id uuid.UUID) (*AttributeTypesToTemplates, error) {
	return c.Query().Where(attributetypestotemplates.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttributeTypesToTemplatesClient) GetX(ctx context.Context, id uuid.UUID) *AttributeTypesToTemplates {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttribute queries the attribute edge of a AttributeTypesToTemplates.
func (c *AttributeTypesToTemplatesClient) QueryAttribute(attt *AttributeTypesToTemplates) *AttributeTypeQuery {
	query := (&AttributeTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := attt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributetypestotemplates.Table, attributetypestotemplates.FieldID, id),
			sqlgraph.To(attributetype.Table, attributetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attributetypestotemplates.AttributeTable, attributetypestotemplates.AttributeColumn),
		)
		fromV = sqlgraph.Neighbors(attt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a AttributeTypesToTemplates.
func (c *AttributeTypesToTemplatesClient) QueryTemplate(attt *AttributeTypesToTemplates) *CertificationTemplateQuery {
	query := (&CertificationTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := attt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attributetypestotemplates.Table, attributetypestotemplates.FieldID, id),
			sqlgraph.To(certificationtemplate.Table, certificationtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, attributetypestotemplates.TemplateTable, attributetypestotemplates.TemplateColumn),
		)
		fromV = sqlgraph.Neighbors(attt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttributeTypesToTemplatesClient) Hooks() []Hook {
	return c.hooks.AttributeTypesToTemplates
}

// Interceptors returns the client interceptors.
func (c *AttributeTypesToTemplatesClient) Interceptors() []Interceptor {
	return c.inters.AttributeTypesToTemplates
}

func (c *AttributeTypesToTemplatesClient) mutate(ctx context.Context, m *AttributeTypesToTemplatesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AttributeTypesToTemplatesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AttributeTypesToTemplatesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AttributeTypesToTemplatesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AttributeTypesToTemplatesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AttributeTypesToTemplates mutation op: %q", m.Op())
	}
}

// AuthorizationPolicyClient is a client for the AuthorizationPolicy schema.
type AuthorizationPolicyClient struct {
	config
}

// NewAuthorizationPolicyClient returns a client for the AuthorizationPolicy from the given config.
func NewAuthorizationPolicyClient(c config) *AuthorizationPolicyClient {
	return &AuthorizationPolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationpolicy.Hooks(f(g(h())))`.
func (c *AuthorizationPolicyClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationPolicy = append(c.hooks.AuthorizationPolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationpolicy.Intercept(f(g(h())))`.
func (c *AuthorizationPolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationPolicy = append(c.inters.AuthorizationPolicy, interceptors...)
}

// Create returns a builder for creating a AuthorizationPolicy entity.
func (c *AuthorizationPolicyClient) Create() *AuthorizationPolicyCreate {
	mutation := newAuthorizationPolicyMutation(c.config, OpCreate)
	return &AuthorizationPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationPolicy entities.
func (c *AuthorizationPolicyClient) CreateBulk(builders ...*AuthorizationPolicyCreate) *AuthorizationPolicyCreateBulk {
	return &AuthorizationPolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationPolicy.
func (c *AuthorizationPolicyClient) Update() *AuthorizationPolicyUpdate {
	mutation := newAuthorizationPolicyMutation(c.config, OpUpdate)
	return &AuthorizationPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationPolicyClient) UpdateOne(ap *AuthorizationPolicy) *AuthorizationPolicyUpdateOne {
	mutation := newAuthorizationPolicyMutation(c.config, OpUpdateOne, withAuthorizationPolicy(ap))
	return &AuthorizationPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationPolicyClient) UpdateOneID(id int) *AuthorizationPolicyUpdateOne {
	mutation := newAuthorizationPolicyMutation(c.config, OpUpdateOne, withAuthorizationPolicyID(id))
	return &AuthorizationPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationPolicy.
func (c *AuthorizationPolicyClient) Delete() *AuthorizationPolicyDelete {
	mutation := newAuthorizationPolicyMutation(c.config, OpDelete)
	return &AuthorizationPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationPolicyClient) DeleteOne(ap *AuthorizationPolicy) *AuthorizationPolicyDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationPolicyClient) DeleteOneID(id int) *AuthorizationPolicyDeleteOne {
	builder := c.Delete().Where(authorizationpolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationPolicyDeleteOne{builder}
}

// Query returns a query builder for AuthorizationPolicy.
func (c *AuthorizationPolicyClient) Query() *AuthorizationPolicyQuery {
	return &AuthorizationPolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationPolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationPolicy entity by its id.
func (c *AuthorizationPolicyClient) Get(ctx context.Context, id int) (*AuthorizationPolicy, error) {
	return c.Query().Where(authorizationpolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationPolicyClient) GetX(ctx context.Context, id int) *AuthorizationPolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthorizationPolicyClient) Hooks() []Hook {
	return c.hooks.AuthorizationPolicy
}

// Interceptors returns the client interceptors.
func (c *AuthorizationPolicyClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationPolicy
}

func (c *AuthorizationPolicyClient) mutate(ctx context.Context, m *AuthorizationPolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationPolicy mutation op: %q", m.Op())
	}
}

// CertificationClient is a client for the Certification schema.
type CertificationClient struct {
	config
}

// NewCertificationClient returns a client for the Certification from the given config.
func NewCertificationClient(c config) *CertificationClient {
	return &CertificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certification.Hooks(f(g(h())))`.
func (c *CertificationClient) Use(hooks ...Hook) {
	c.hooks.Certification = append(c.hooks.Certification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certification.Intercept(f(g(h())))`.
func (c *CertificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Certification = append(c.inters.Certification, interceptors...)
}

// Create returns a builder for creating a Certification entity.
func (c *CertificationClient) Create() *CertificationCreate {
	mutation := newCertificationMutation(c.config, OpCreate)
	return &CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Certification entities.
func (c *CertificationClient) CreateBulk(builders ...*CertificationCreate) *CertificationCreateBulk {
	return &CertificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Certification.
func (c *CertificationClient) Update() *CertificationUpdate {
	mutation := newCertificationMutation(c.config, OpUpdate)
	return &CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificationClient) UpdateOne(ce *Certification) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertification(ce))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificationClient) UpdateOneID(id uuid.UUID) *CertificationUpdateOne {
	mutation := newCertificationMutation(c.config, OpUpdateOne, withCertificationID(id))
	return &CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Certification.
func (c *CertificationClient) Delete() *CertificationDelete {
	mutation := newCertificationMutation(c.config, OpDelete)
	return &CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificationClient) DeleteOne(ce *Certification) *CertificationDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificationClient) DeleteOneID(id uuid.UUID) *CertificationDeleteOne {
	builder := c.Delete().Where(certification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificationDeleteOne{builder}
}

// Query returns a query builder for Certification.
func (c *CertificationClient) Query() *CertificationQuery {
	return &CertificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertification},
		inters: c.Interceptors(),
	}
}

// Get returns a Certification entity by its id.
func (c *CertificationClient) Get(ctx context.Context, id uuid.UUID) (*Certification, error) {
	return c.Query().Where(certification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificationClient) GetX(ctx context.Context, id uuid.UUID) *Certification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a Certification.
func (c *CertificationClient) QueryCompany(ce *Certification) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.CompanyTable, certification.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItemBatch queries the itemBatch edge of a Certification.
func (c *CertificationClient) QueryItemBatch(ce *Certification) *ItemBatchQuery {
	query := (&ItemBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(itembatch.Table, itembatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.ItemBatchTable, certification.ItemBatchColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTemplate queries the template edge of a Certification.
func (c *CertificationClient) QueryTemplate(ce *Certification) *CertificationTemplateQuery {
	query := (&CertificationTemplateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certification.Table, certification.FieldID, id),
			sqlgraph.To(certificationtemplate.Table, certificationtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certification.TemplateTable, certification.TemplateColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificationClient) Hooks() []Hook {
	return c.hooks.Certification
}

// Interceptors returns the client interceptors.
func (c *CertificationClient) Interceptors() []Interceptor {
	return c.inters.Certification
}

func (c *CertificationClient) mutate(ctx context.Context, m *CertificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Certification mutation op: %q", m.Op())
	}
}

// CertificationTemplateClient is a client for the CertificationTemplate schema.
type CertificationTemplateClient struct {
	config
}

// NewCertificationTemplateClient returns a client for the CertificationTemplate from the given config.
func NewCertificationTemplateClient(c config) *CertificationTemplateClient {
	return &CertificationTemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificationtemplate.Hooks(f(g(h())))`.
func (c *CertificationTemplateClient) Use(hooks ...Hook) {
	c.hooks.CertificationTemplate = append(c.hooks.CertificationTemplate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificationtemplate.Intercept(f(g(h())))`.
func (c *CertificationTemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.CertificationTemplate = append(c.inters.CertificationTemplate, interceptors...)
}

// Create returns a builder for creating a CertificationTemplate entity.
func (c *CertificationTemplateClient) Create() *CertificationTemplateCreate {
	mutation := newCertificationTemplateMutation(c.config, OpCreate)
	return &CertificationTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CertificationTemplate entities.
func (c *CertificationTemplateClient) CreateBulk(builders ...*CertificationTemplateCreate) *CertificationTemplateCreateBulk {
	return &CertificationTemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CertificationTemplate.
func (c *CertificationTemplateClient) Update() *CertificationTemplateUpdate {
	mutation := newCertificationTemplateMutation(c.config, OpUpdate)
	return &CertificationTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificationTemplateClient) UpdateOne(ct *CertificationTemplate) *CertificationTemplateUpdateOne {
	mutation := newCertificationTemplateMutation(c.config, OpUpdateOne, withCertificationTemplate(ct))
	return &CertificationTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificationTemplateClient) UpdateOneID(id uuid.UUID) *CertificationTemplateUpdateOne {
	mutation := newCertificationTemplateMutation(c.config, OpUpdateOne, withCertificationTemplateID(id))
	return &CertificationTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CertificationTemplate.
func (c *CertificationTemplateClient) Delete() *CertificationTemplateDelete {
	mutation := newCertificationTemplateMutation(c.config, OpDelete)
	return &CertificationTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificationTemplateClient) DeleteOne(ct *CertificationTemplate) *CertificationTemplateDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificationTemplateClient) DeleteOneID(id uuid.UUID) *CertificationTemplateDeleteOne {
	builder := c.Delete().Where(certificationtemplate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificationTemplateDeleteOne{builder}
}

// Query returns a query builder for CertificationTemplate.
func (c *CertificationTemplateClient) Query() *CertificationTemplateQuery {
	return &CertificationTemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificationTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a CertificationTemplate entity by its id.
func (c *CertificationTemplateClient) Get(ctx context.Context, id uuid.UUID) (*CertificationTemplate, error) {
	return c.Query().Where(certificationtemplate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificationTemplateClient) GetX(ctx context.Context, id uuid.UUID) *CertificationTemplate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a CertificationTemplate.
func (c *CertificationTemplateClient) QueryCompany(ct *CertificationTemplate) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ct.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(certificationtemplate.Table, certificationtemplate.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, certificationtemplate.CompanyTable, certificationtemplate.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ct.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CertificationTemplateClient) Hooks() []Hook {
	return c.hooks.CertificationTemplate
}

// Interceptors returns the client interceptors.
func (c *CertificationTemplateClient) Interceptors() []Interceptor {
	return c.inters.CertificationTemplate
}

func (c *CertificationTemplateClient) mutate(ctx context.Context, m *CertificationTemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificationTemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificationTemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificationTemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificationTemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CertificationTemplate mutation op: %q", m.Op())
	}
}

// CompanyClient is a client for the Company schema.
type CompanyClient struct {
	config
}

// NewCompanyClient returns a client for the Company from the given config.
func NewCompanyClient(c config) *CompanyClient {
	return &CompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `company.Hooks(f(g(h())))`.
func (c *CompanyClient) Use(hooks ...Hook) {
	c.hooks.Company = append(c.hooks.Company, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `company.Intercept(f(g(h())))`.
func (c *CompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Company = append(c.inters.Company, interceptors...)
}

// Create returns a builder for creating a Company entity.
func (c *CompanyClient) Create() *CompanyCreate {
	mutation := newCompanyMutation(c.config, OpCreate)
	return &CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Company entities.
func (c *CompanyClient) CreateBulk(builders ...*CompanyCreate) *CompanyCreateBulk {
	return &CompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Company.
func (c *CompanyClient) Update() *CompanyUpdate {
	mutation := newCompanyMutation(c.config, OpUpdate)
	return &CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompanyClient) UpdateOne(co *Company) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompany(co))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompanyClient) UpdateOneID(id uuid.UUID) *CompanyUpdateOne {
	mutation := newCompanyMutation(c.config, OpUpdateOne, withCompanyID(id))
	return &CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Company.
func (c *CompanyClient) Delete() *CompanyDelete {
	mutation := newCompanyMutation(c.config, OpDelete)
	return &CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompanyClient) DeleteOne(co *Company) *CompanyDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompanyClient) DeleteOneID(id uuid.UUID) *CompanyDeleteOne {
	builder := c.Delete().Where(company.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompanyDeleteOne{builder}
}

// Query returns a query builder for Company.
func (c *CompanyClient) Query() *CompanyQuery {
	return &CompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a Company entity by its id.
func (c *CompanyClient) Get(ctx context.Context, id uuid.UUID) (*Company, error) {
	return c.Query().Where(company.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompanyClient) GetX(ctx context.Context, id uuid.UUID) *Company {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CompanyClient) Hooks() []Hook {
	return c.hooks.Company
}

// Interceptors returns the client interceptors.
func (c *CompanyClient) Interceptors() []Interceptor {
	return c.inters.Company
}

func (c *CompanyClient) mutate(ctx context.Context, m *CompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Company mutation op: %q", m.Op())
	}
}

// ItemBatchClient is a client for the ItemBatch schema.
type ItemBatchClient struct {
	config
}

// NewItemBatchClient returns a client for the ItemBatch from the given config.
func NewItemBatchClient(c config) *ItemBatchClient {
	return &ItemBatchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `itembatch.Hooks(f(g(h())))`.
func (c *ItemBatchClient) Use(hooks ...Hook) {
	c.hooks.ItemBatch = append(c.hooks.ItemBatch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `itembatch.Intercept(f(g(h())))`.
func (c *ItemBatchClient) Intercept(interceptors ...Interceptor) {
	c.inters.ItemBatch = append(c.inters.ItemBatch, interceptors...)
}

// Create returns a builder for creating a ItemBatch entity.
func (c *ItemBatchClient) Create() *ItemBatchCreate {
	mutation := newItemBatchMutation(c.config, OpCreate)
	return &ItemBatchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ItemBatch entities.
func (c *ItemBatchClient) CreateBulk(builders ...*ItemBatchCreate) *ItemBatchCreateBulk {
	return &ItemBatchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ItemBatch.
func (c *ItemBatchClient) Update() *ItemBatchUpdate {
	mutation := newItemBatchMutation(c.config, OpUpdate)
	return &ItemBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ItemBatchClient) UpdateOne(ib *ItemBatch) *ItemBatchUpdateOne {
	mutation := newItemBatchMutation(c.config, OpUpdateOne, withItemBatch(ib))
	return &ItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ItemBatchClient) UpdateOneID(id uuid.UUID) *ItemBatchUpdateOne {
	mutation := newItemBatchMutation(c.config, OpUpdateOne, withItemBatchID(id))
	return &ItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ItemBatch.
func (c *ItemBatchClient) Delete() *ItemBatchDelete {
	mutation := newItemBatchMutation(c.config, OpDelete)
	return &ItemBatchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ItemBatchClient) DeleteOne(ib *ItemBatch) *ItemBatchDeleteOne {
	return c.DeleteOneID(ib.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ItemBatchClient) DeleteOneID(id uuid.UUID) *ItemBatchDeleteOne {
	builder := c.Delete().Where(itembatch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ItemBatchDeleteOne{builder}
}

// Query returns a query builder for ItemBatch.
func (c *ItemBatchClient) Query() *ItemBatchQuery {
	return &ItemBatchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeItemBatch},
		inters: c.Interceptors(),
	}
}

// Get returns a ItemBatch entity by its id.
func (c *ItemBatchClient) Get(ctx context.Context, id uuid.UUID) (*ItemBatch, error) {
	return c.Query().Where(itembatch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ItemBatchClient) GetX(ctx context.Context, id uuid.UUID) *ItemBatch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompany queries the company edge of a ItemBatch.
func (c *ItemBatchClient) QueryCompany(ib *ItemBatch) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ib.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(itembatch.Table, itembatch.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, itembatch.CompanyTable, itembatch.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(ib.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ItemBatchClient) Hooks() []Hook {
	return c.hooks.ItemBatch
}

// Interceptors returns the client interceptors.
func (c *ItemBatchClient) Interceptors() []Interceptor {
	return c.inters.ItemBatch
}

func (c *ItemBatchClient) mutate(ctx context.Context, m *ItemBatchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ItemBatchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ItemBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ItemBatchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ItemBatch mutation op: %q", m.Op())
	}
}

// ItemBatchToItemBatchClient is a client for the ItemBatchToItemBatch schema.
type ItemBatchToItemBatchClient struct {
	config
}

// NewItemBatchToItemBatchClient returns a client for the ItemBatchToItemBatch from the given config.
func NewItemBatchToItemBatchClient(c config) *ItemBatchToItemBatchClient {
	return &ItemBatchToItemBatchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `itembatchtoitembatch.Hooks(f(g(h())))`.
func (c *ItemBatchToItemBatchClient) Use(hooks ...Hook) {
	c.hooks.ItemBatchToItemBatch = append(c.hooks.ItemBatchToItemBatch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `itembatchtoitembatch.Intercept(f(g(h())))`.
func (c *ItemBatchToItemBatchClient) Intercept(interceptors ...Interceptor) {
	c.inters.ItemBatchToItemBatch = append(c.inters.ItemBatchToItemBatch, interceptors...)
}

// Create returns a builder for creating a ItemBatchToItemBatch entity.
func (c *ItemBatchToItemBatchClient) Create() *ItemBatchToItemBatchCreate {
	mutation := newItemBatchToItemBatchMutation(c.config, OpCreate)
	return &ItemBatchToItemBatchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ItemBatchToItemBatch entities.
func (c *ItemBatchToItemBatchClient) CreateBulk(builders ...*ItemBatchToItemBatchCreate) *ItemBatchToItemBatchCreateBulk {
	return &ItemBatchToItemBatchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ItemBatchToItemBatch.
func (c *ItemBatchToItemBatchClient) Update() *ItemBatchToItemBatchUpdate {
	mutation := newItemBatchToItemBatchMutation(c.config, OpUpdate)
	return &ItemBatchToItemBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ItemBatchToItemBatchClient) UpdateOne(ibtib *ItemBatchToItemBatch) *ItemBatchToItemBatchUpdateOne {
	mutation := newItemBatchToItemBatchMutation(c.config, OpUpdateOne, withItemBatchToItemBatch(ibtib))
	return &ItemBatchToItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ItemBatchToItemBatchClient) UpdateOneID(id uuid.UUID) *ItemBatchToItemBatchUpdateOne {
	mutation := newItemBatchToItemBatchMutation(c.config, OpUpdateOne, withItemBatchToItemBatchID(id))
	return &ItemBatchToItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ItemBatchToItemBatch.
func (c *ItemBatchToItemBatchClient) Delete() *ItemBatchToItemBatchDelete {
	mutation := newItemBatchToItemBatchMutation(c.config, OpDelete)
	return &ItemBatchToItemBatchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ItemBatchToItemBatchClient) DeleteOne(ibtib *ItemBatchToItemBatch) *ItemBatchToItemBatchDeleteOne {
	return c.DeleteOneID(ibtib.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ItemBatchToItemBatchClient) DeleteOneID(id uuid.UUID) *ItemBatchToItemBatchDeleteOne {
	builder := c.Delete().Where(itembatchtoitembatch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ItemBatchToItemBatchDeleteOne{builder}
}

// Query returns a query builder for ItemBatchToItemBatch.
func (c *ItemBatchToItemBatchClient) Query() *ItemBatchToItemBatchQuery {
	return &ItemBatchToItemBatchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeItemBatchToItemBatch},
		inters: c.Interceptors(),
	}
}

// Get returns a ItemBatchToItemBatch entity by its id.
func (c *ItemBatchToItemBatchClient) Get(ctx context.Context, id uuid.UUID) (*ItemBatchToItemBatch, error) {
	return c.Query().Where(itembatchtoitembatch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ItemBatchToItemBatchClient) GetX(ctx context.Context, id uuid.UUID) *ItemBatchToItemBatch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a ItemBatchToItemBatch.
func (c *ItemBatchToItemBatchClient) QueryParent(ibtib *ItemBatchToItemBatch) *ItemBatchQuery {
	query := (&ItemBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ibtib.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(itembatchtoitembatch.Table, itembatchtoitembatch.FieldID, id),
			sqlgraph.To(itembatch.Table, itembatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, itembatchtoitembatch.ParentTable, itembatchtoitembatch.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(ibtib.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChild queries the child edge of a ItemBatchToItemBatch.
func (c *ItemBatchToItemBatchClient) QueryChild(ibtib *ItemBatchToItemBatch) *ItemBatchQuery {
	query := (&ItemBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ibtib.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(itembatchtoitembatch.Table, itembatchtoitembatch.FieldID, id),
			sqlgraph.To(itembatch.Table, itembatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, itembatchtoitembatch.ChildTable, itembatchtoitembatch.ChildColumn),
		)
		fromV = sqlgraph.Neighbors(ibtib.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ItemBatchToItemBatchClient) Hooks() []Hook {
	return c.hooks.ItemBatchToItemBatch
}

// Interceptors returns the client interceptors.
func (c *ItemBatchToItemBatchClient) Interceptors() []Interceptor {
	return c.inters.ItemBatchToItemBatch
}

func (c *ItemBatchToItemBatchClient) mutate(ctx context.Context, m *ItemBatchToItemBatchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ItemBatchToItemBatchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ItemBatchToItemBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ItemBatchToItemBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ItemBatchToItemBatchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ItemBatchToItemBatch mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id int) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id int) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id int) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id int) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UsersToCompanyClient is a client for the UsersToCompany schema.
type UsersToCompanyClient struct {
	config
}

// NewUsersToCompanyClient returns a client for the UsersToCompany from the given config.
func NewUsersToCompanyClient(c config) *UsersToCompanyClient {
	return &UsersToCompanyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userstocompany.Hooks(f(g(h())))`.
func (c *UsersToCompanyClient) Use(hooks ...Hook) {
	c.hooks.UsersToCompany = append(c.hooks.UsersToCompany, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userstocompany.Intercept(f(g(h())))`.
func (c *UsersToCompanyClient) Intercept(interceptors ...Interceptor) {
	c.inters.UsersToCompany = append(c.inters.UsersToCompany, interceptors...)
}

// Create returns a builder for creating a UsersToCompany entity.
func (c *UsersToCompanyClient) Create() *UsersToCompanyCreate {
	mutation := newUsersToCompanyMutation(c.config, OpCreate)
	return &UsersToCompanyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UsersToCompany entities.
func (c *UsersToCompanyClient) CreateBulk(builders ...*UsersToCompanyCreate) *UsersToCompanyCreateBulk {
	return &UsersToCompanyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UsersToCompany.
func (c *UsersToCompanyClient) Update() *UsersToCompanyUpdate {
	mutation := newUsersToCompanyMutation(c.config, OpUpdate)
	return &UsersToCompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsersToCompanyClient) UpdateOne(utc *UsersToCompany) *UsersToCompanyUpdateOne {
	mutation := newUsersToCompanyMutation(c.config, OpUpdateOne, withUsersToCompany(utc))
	return &UsersToCompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsersToCompanyClient) UpdateOneID(id uuid.UUID) *UsersToCompanyUpdateOne {
	mutation := newUsersToCompanyMutation(c.config, OpUpdateOne, withUsersToCompanyID(id))
	return &UsersToCompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UsersToCompany.
func (c *UsersToCompanyClient) Delete() *UsersToCompanyDelete {
	mutation := newUsersToCompanyMutation(c.config, OpDelete)
	return &UsersToCompanyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsersToCompanyClient) DeleteOne(utc *UsersToCompany) *UsersToCompanyDeleteOne {
	return c.DeleteOneID(utc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsersToCompanyClient) DeleteOneID(id uuid.UUID) *UsersToCompanyDeleteOne {
	builder := c.Delete().Where(userstocompany.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsersToCompanyDeleteOne{builder}
}

// Query returns a query builder for UsersToCompany.
func (c *UsersToCompanyClient) Query() *UsersToCompanyQuery {
	return &UsersToCompanyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsersToCompany},
		inters: c.Interceptors(),
	}
}

// Get returns a UsersToCompany entity by its id.
func (c *UsersToCompanyClient) Get(ctx context.Context, id uuid.UUID) (*UsersToCompany, error) {
	return c.Query().Where(userstocompany.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsersToCompanyClient) GetX(ctx context.Context, id uuid.UUID) *UsersToCompany {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UsersToCompany.
func (c *UsersToCompanyClient) QueryUser(utc *UsersToCompany) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := utc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userstocompany.Table, userstocompany.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userstocompany.UserTable, userstocompany.UserColumn),
		)
		fromV = sqlgraph.Neighbors(utc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompany queries the company edge of a UsersToCompany.
func (c *UsersToCompanyClient) QueryCompany(utc *UsersToCompany) *CompanyQuery {
	query := (&CompanyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := utc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userstocompany.Table, userstocompany.FieldID, id),
			sqlgraph.To(company.Table, company.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userstocompany.CompanyTable, userstocompany.CompanyColumn),
		)
		fromV = sqlgraph.Neighbors(utc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsersToCompanyClient) Hooks() []Hook {
	return c.hooks.UsersToCompany
}

// Interceptors returns the client interceptors.
func (c *UsersToCompanyClient) Interceptors() []Interceptor {
	return c.inters.UsersToCompany
}

func (c *UsersToCompanyClient) mutate(ctx context.Context, m *UsersToCompanyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsersToCompanyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsersToCompanyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsersToCompanyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsersToCompanyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UsersToCompany mutation op: %q", m.Op())
	}
}
