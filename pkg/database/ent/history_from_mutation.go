// Code generated by enthistory, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent"

	"git.las.iastate.edu/SeniorDesignComS/2023spr/online-certificate-repo/backend/pkg/database/enthistory"
)

var (
	idNotFoundError = errors.New("could not get id from mutation")
)

func EntOpToHistoryOp(op ent.Op) enthistory.OpType {
	switch op {
	case ent.OpDelete, ent.OpDeleteOne:
		return enthistory.OpTypeDelete
	case ent.OpUpdate, ent.OpUpdateOne:
		return enthistory.OpTypeUpdate
	default:
		return enthistory.OpTypeInsert
	}
}

func rollback(tx *Tx, err error) error {
	if tx != nil {
		if rerr := tx.Rollback(); rerr != nil {
			err = fmt.Errorf("%w: %v", err, rerr)
		}
		return err
	}
	return err
}

func (m *AttributeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.AttributeHistory.Create()
	if tx != nil {
		create = tx.AttributeHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if key, exists := m.Key(); exists {
		create = create.SetKey(key)
	}

	if value, exists := m.Value(); exists {
		create = create.SetValue(value)
	}

	if certuuid, exists := m.CertUUID(); exists {
		create = create.SetCertUUID(certuuid)
	}

	if attributetypeuuid, exists := m.AttributeTypeUUID(); exists {
		create = create.SetAttributeTypeUUID(attributetypeuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *AttributeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	attribute, err := client.Attribute.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.AttributeHistory.Create()
	if tx != nil {
		create = tx.AttributeHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if key, exists := m.Key(); exists {
		create = create.SetKey(key)
	} else {
		create = create.SetKey(attribute.Key)
	}

	if value, exists := m.Value(); exists {
		create = create.SetValue(value)
	} else {
		create = create.SetValue(attribute.Value)
	}

	if certuuid, exists := m.CertUUID(); exists {
		create = create.SetCertUUID(certuuid)
	} else {
		create = create.SetCertUUID(attribute.CertUUID)
	}

	if attributetypeuuid, exists := m.AttributeTypeUUID(); exists {
		create = create.SetAttributeTypeUUID(attributetypeuuid)
	} else {
		create = create.SetAttributeTypeUUID(attribute.AttributeTypeUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *AttributeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	attribute, err := client.Attribute.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.AttributeHistory.Create()
	if tx != nil {
		create = tx.AttributeHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetKey(attribute.Key).
		SetValue(attribute.Value).
		SetCertUUID(attribute.CertUUID).
		SetAttributeTypeUUID(attribute.AttributeTypeUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *AttributeTypeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.AttributeTypeHistory.Create()
	if tx != nil {
		create = tx.AttributeTypeHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if key, exists := m.Key(); exists {
		create = create.SetKey(key)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *AttributeTypeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	attributetype, err := client.AttributeType.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.AttributeTypeHistory.Create()
	if tx != nil {
		create = tx.AttributeTypeHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if key, exists := m.Key(); exists {
		create = create.SetKey(key)
	} else {
		create = create.SetKey(attributetype.Key)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	} else {
		create = create.SetCompanyUUID(attributetype.CompanyUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *AttributeTypeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	attributetype, err := client.AttributeType.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.AttributeTypeHistory.Create()
	if tx != nil {
		create = tx.AttributeTypeHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetKey(attributetype.Key).
		SetCompanyUUID(attributetype.CompanyUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.CertificationHistory.Create()
	if tx != nil {
		create = tx.CertificationHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if primaryattribute, exists := m.PrimaryAttribute(); exists {
		create = create.SetPrimaryAttribute(primaryattribute)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	}

	if itembatchuuid, exists := m.ItemBatchUUID(); exists {
		create = create.SetItemBatchUUID(itembatchuuid)
	}

	if imageuuid, exists := m.ImageUUID(); exists {
		create = create.SetImageUUID(imageuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	certification, err := client.Certification.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CertificationHistory.Create()
	if tx != nil {
		create = tx.CertificationHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if primaryattribute, exists := m.PrimaryAttribute(); exists {
		create = create.SetPrimaryAttribute(primaryattribute)
	} else {
		create = create.SetPrimaryAttribute(certification.PrimaryAttribute)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	} else {
		create = create.SetCompanyUUID(certification.CompanyUUID)
	}

	if itembatchuuid, exists := m.ItemBatchUUID(); exists {
		create = create.SetItemBatchUUID(itembatchuuid)
	} else {
		create = create.SetItemBatchUUID(certification.ItemBatchUUID)
	}

	if imageuuid, exists := m.ImageUUID(); exists {
		create = create.SetImageUUID(imageuuid)
	} else {
		create = create.SetImageUUID(certification.ImageUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	certification, err := client.Certification.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CertificationHistory.Create()
	if tx != nil {
		create = tx.CertificationHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetPrimaryAttribute(certification.PrimaryAttribute).
		SetCompanyUUID(certification.CompanyUUID).
		SetItemBatchUUID(certification.ItemBatchUUID).
		SetImageUUID(certification.ImageUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationTemplateMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.CertificationTemplateHistory.Create()
	if tx != nil {
		create = tx.CertificationTemplateHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationTemplateMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	certificationtemplate, err := client.CertificationTemplate.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CertificationTemplateHistory.Create()
	if tx != nil {
		create = tx.CertificationTemplateHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	} else {
		create = create.SetDescription(certificationtemplate.Description)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	} else {
		create = create.SetCompanyUUID(certificationtemplate.CompanyUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CertificationTemplateMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	certificationtemplate, err := client.CertificationTemplate.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CertificationTemplateHistory.Create()
	if tx != nil {
		create = tx.CertificationTemplateHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetDescription(certificationtemplate.Description).
		SetCompanyUUID(certificationtemplate.CompanyUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CompanyMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.CompanyHistory.Create()
	if tx != nil {
		create = tx.CompanyHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CompanyMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	company, err := client.Company.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CompanyHistory.Create()
	if tx != nil {
		create = tx.CompanyHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	} else {
		create = create.SetName(company.Name)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *CompanyMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	company, err := client.Company.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.CompanyHistory.Create()
	if tx != nil {
		create = tx.CompanyHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetName(company.Name).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.ItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if itemnumber, exists := m.ItemNumber(); exists {
		create = create.SetItemNumber(itemnumber)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	itembatch, err := client.ItemBatch.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.ItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if itemnumber, exists := m.ItemNumber(); exists {
		create = create.SetItemNumber(itemnumber)
	} else {
		create = create.SetItemNumber(itembatch.ItemNumber)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	} else {
		create = create.SetDescription(itembatch.Description)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	} else {
		create = create.SetCompanyUUID(itembatch.CompanyUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	itembatch, err := client.ItemBatch.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.ItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetItemNumber(itembatch.ItemNumber).
		SetDescription(itembatch.Description).
		SetCompanyUUID(itembatch.CompanyUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchToItemBatchMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.ItemBatchToItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchToItemBatchHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if childuuid, exists := m.ChildUUID(); exists {
		create = create.SetChildUUID(childuuid)
	}

	if parentuuid, exists := m.ParentUUID(); exists {
		create = create.SetParentUUID(parentuuid)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchToItemBatchMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	itembatchtoitembatch, err := client.ItemBatchToItemBatch.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.ItemBatchToItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchToItemBatchHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if childuuid, exists := m.ChildUUID(); exists {
		create = create.SetChildUUID(childuuid)
	} else {
		create = create.SetChildUUID(itembatchtoitembatch.ChildUUID)
	}

	if parentuuid, exists := m.ParentUUID(); exists {
		create = create.SetParentUUID(parentuuid)
	} else {
		create = create.SetParentUUID(itembatchtoitembatch.ParentUUID)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *ItemBatchToItemBatchMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	itembatchtoitembatch, err := client.ItemBatchToItemBatch.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.ItemBatchToItemBatchHistory.Create()
	if tx != nil {
		create = tx.ItemBatchToItemBatchHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetChildUUID(itembatchtoitembatch.ChildUUID).
		SetParentUUID(itembatchtoitembatch.ParentUUID).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UserMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.UserHistory.Create()
	if tx != nil {
		create = tx.UserHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if passwordHash, exists := m.PasswordHash(); exists {
		create = create.SetPasswordHash(passwordHash)
	}

	if attemptCount, exists := m.AttemptCount(); exists {
		create = create.SetAttemptCount(attemptCount)
	}

	if lastAttempt, exists := m.LastAttempt(); exists {
		create = create.SetLastAttempt(lastAttempt)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UserMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	user, err := client.User.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.UserHistory.Create()
	if tx != nil {
		create = tx.UserHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	} else {
		create = create.SetEmail(user.Email)
	}

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	} else {
		create = create.SetCreatedAt(user.CreatedAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	} else {
		create = create.SetUpdatedAt(user.UpdatedAt)
	}

	if passwordHash, exists := m.PasswordHash(); exists {
		create = create.SetPasswordHash(passwordHash)
	} else {
		create = create.SetPasswordHash(user.PasswordHash)
	}

	if attemptCount, exists := m.AttemptCount(); exists {
		create = create.SetAttemptCount(attemptCount)
	} else {
		create = create.SetAttemptCount(user.AttemptCount)
	}

	if lastAttempt, exists := m.LastAttempt(); exists {
		create = create.SetLastAttempt(lastAttempt)
	} else {
		create = create.SetLastAttempt(user.LastAttempt)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	} else {
		create = create.SetLocked(user.Locked)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	} else {
		create = create.SetRole(user.Role)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UserMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	user, err := client.User.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.UserHistory.Create()
	if tx != nil {
		create = tx.UserHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetEmail(user.Email).
		SetCreatedAt(user.CreatedAt).
		SetUpdatedAt(user.UpdatedAt).
		SetPasswordHash(user.PasswordHash).
		SetAttemptCount(user.AttemptCount).
		SetLastAttempt(user.LastAttempt).
		SetLocked(user.Locked).
		SetRole(user.Role).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UsersToCompanyMutation) CreateHistoryFromCreate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	create := client.UsersToCompanyHistory.Create()
	if tx != nil {
		create = tx.UsersToCompanyHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	}

	if useruuid, exists := m.UserUUID(); exists {
		create = create.SetUserUUID(useruuid)
	}

	if roletype, exists := m.RoleType(); exists {
		create = create.SetRoleType(roletype)
	}

	if approved, exists := m.Approved(); exists {
		create = create.SetApproved(approved)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UsersToCompanyMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	userstocompany, err := client.UsersToCompany.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.UsersToCompanyHistory.Create()
	if tx != nil {
		create = tx.UsersToCompanyHistory.Create()
	}
	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	if companyuuid, exists := m.CompanyUUID(); exists {
		create = create.SetCompanyUUID(companyuuid)
	} else {
		create = create.SetCompanyUUID(userstocompany.CompanyUUID)
	}

	if useruuid, exists := m.UserUUID(); exists {
		create = create.SetUserUUID(useruuid)
	} else {
		create = create.SetUserUUID(userstocompany.UserUUID)
	}

	if roletype, exists := m.RoleType(); exists {
		create = create.SetRoleType(roletype)
	} else {
		create = create.SetRoleType(userstocompany.RoleType)
	}

	if approved, exists := m.Approved(); exists {
		create = create.SetApproved(approved)
	} else {
		create = create.SetApproved(userstocompany.Approved)
	}

	_, err = create.Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}

func (m *UsersToCompanyMutation) CreateHistoryFromDelete(ctx context.Context) error {
	client := m.Client()
	tx, err := m.Tx()
	if err != nil {
		tx = nil
	}

	updatedBy, _ := ctx.Value("userUUID").(string)

	id, ok := m.ID()
	if !ok {
		return rollback(tx, idNotFoundError)
	}

	userstocompany, err := client.UsersToCompany.Get(ctx, id)
	if err != nil {
		return rollback(tx, err)
	}

	create := client.UsersToCompanyHistory.Create()
	if tx != nil {
		create = tx.UsersToCompanyHistory.Create()
	}
	if updatedBy != "" {
		create = create.SetUpdatedBy(updatedBy)
	}

	_, err = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id).
		SetCompanyUUID(userstocompany.CompanyUUID).
		SetUserUUID(userstocompany.UserUUID).
		SetRoleType(userstocompany.RoleType).
		SetApproved(userstocompany.Approved).
		Save(ctx)
	if err != nil {
		rollback(tx, err)
	}
	return nil
}
